//
//  UsersVoteShowInteractor.swift
//  golos-ios
//
//  Created by msm72 on 10/25/18.
//  Copyright (c) 2018 golos. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit
import GoloSwift

// MARK: - Business Logic protocols
protocol UsersVoteShowBusinessLogic {
    func subscribe(withRequestModel requestModel: UsersVoteShowModels.Sub.RequestModel)
    func loadUsersVoted(withRequestModel requestModel: UsersVoteShowModels.Item.RequestModel)
}

protocol UsersVoteShowDataStore {
    var permlink: String! { get set }
    var authorNickName: String! { get set }
    var usersVoteMode: UsersVoteMode! { get set }
}

@objc enum UsersVoteMode: Int {
    case like
    case dislike
}

class UsersVoteShowInteractor: UsersVoteShowBusinessLogic, UsersVoteShowDataStore {
    // MARK: - Properties
    var presenter: UsersVoteShowPresentationLogic?
    
    // UsersVoteShowDataStore protocol implementation
    var permlink: String!
    var authorNickName: String!
    var usersVoteMode: UsersVoteMode!

    
    // MARK: - Class Initialization
    deinit {
        Logger.log(message: "Success", event: .severe)
    }
    

    // MARK: - Business logic implementation
    func subscribe(withRequestModel requestModel: UsersVoteShowModels.Sub.RequestModel) {
//        let subscription = RequestParameterAPI.Subscription(userNickName:       User.current!.nickName,
//                                                            authorNickName:     self.postShortInfo!.author ?? "XXX",
//                                                            what:               requestModel.willSubscribe ? "blog" : nil)
//
//        let operationAPIType = OperationAPIType.subscribe(fields: subscription)
//        let postRequestQueue = DispatchQueue.global(qos: .background)
//
//        postRequestQueue.async {
//            broadcast.executePOST(requestByOperationAPIType:    operationAPIType,
//                                  userNickName:                 User.current!.nickName,
//                                  onResult:                     { [weak self] responseAPIResult in
//                                    var errorAPI: ErrorAPI?
//
//                                    if let error = (responseAPIResult as! ResponseAPIBlockchainPostResult).error {
//                                        errorAPI = ErrorAPI.requestFailed(message: error.message)
//                                    }
//
//                                    let isFollowing = errorAPI == nil && requestModel.willSubscribe
//
//                                    let responseModel = PostShowModels.Item.ResponseModel(isFollowing: isFollowing, errorAPI: errorAPI)
//                                    self?.presenter?.presentSubscribe(fromResponseModel: responseModel)
//                },
//                                  onError: { [weak self] errorAPI in
//                                    Logger.log(message: "nresponse API Error = \(errorAPI.caseInfo.message)\n", event: .error)
//                                    let responseModel = PostShowModels.Item.ResponseModel(isFollowing: false, errorAPI: errorAPI)
//                                    self?.presenter?.presentSubscribe(fromResponseModel: responseModel)
//            })
//        }
    }

    func loadUsersVoted(withRequestModel requestModel: UsersVoteShowModels.Item.RequestModel) {
        let responseModel = UsersVoteShowModels.Item.ResponseModel(errorAPI: nil)
        presenter?.presentLoadUsersVoted(fromResponseModel: responseModel)
    }
}
