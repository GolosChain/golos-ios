//
//  PostCreateViewController.swift
//  golos-ios
//
//  Created by msm72 on 11.06.2018.
//  Copyright (c) 2018 golos. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit
import GoloSwift
import IQKeyboardManagerSwift

enum SceneType: Int {
    case create = 0
    case comment
    case reply
}

// MARK: - Input & Output protocols
protocol PostCreateDisplayLogic: class {
    func displayPostCreate(fromViewModel viewModel: PostCreateModels.Post.ViewModel)
    func displayPostComment(fromViewModel viewModel: PostCreateModels.Post.ViewModel)
    func displayPostCommentReply(fromViewModel viewModel: PostCreateModels.Post.ViewModel)
}

class PostCreateViewController: GSBaseViewController {
    // MARK: - Properties
    var firstResponder: UIView!
    var isKeyboardShow = false
    
    var tagsVC: TagsCollectionViewController!

    var sceneType: SceneType = .create {
        didSet {
            self.navigationItem.title           =   (sceneType == .create) ? "Publish Title".localized() : "Comment Title Verb".localized()
            stackViewTopConstraint.constant     =   (sceneType == .comment) ? -70.0 * widthRatio : 0.0
            
            _ = sceneViewsCollection.map({ $0.isHidden = ($0.tag == sceneType.rawValue) ? false : true })
            
            if sceneType == .reply {
//                self.commentReplyView.commentLabel.text = self.router?.dataStore?.commentText
            }
        }
    }
    
    var interactor: PostCreateBusinessLogic?
    var router: (NSObjectProtocol & PostCreateRoutingLogic & PostCreateDataPassing)?
    
    
    // MARK: - IBOutlets
    @IBOutlet weak var postCreateView: PostCreateView! {
        didSet {
            postCreateView.completionStartEditing   =   { [weak self] isEdit in
                self?.firstResponder    =   self?.postCreateView
                self?.isKeyboardShow    =   isEdit
                
                self?.setConstraint()
            }
        }
    }
    
    @IBOutlet weak var commentReplyView: PostCommentReply! {
        didSet {
        }
    }
    
    @IBOutlet weak var shadowView: UIView! {
        didSet {
            shadowView.setGradientBackground(colors: [UIColor.lightGray.cgColor, UIColor.lightText.cgColor], onside: .bottom)
        }
    }

    @IBOutlet weak var tagsTitleLabel: UILabel! {
        didSet {
            tagsTitleLabel.tune(withText:           "Add Max 5 Tags",
                                hexColors:          darkGrayWhiteColorPickers,
                                font:               UIFont(name: "SFUIDisplay-Regular", size: 12.0 * widthRatio),
                                alignment:          .left,
                                isMultiLines:       false)
        }
    }
    
    @IBOutlet weak var contentTextView: UITextView! {
        didSet {
            contentTextView.contentInset    =   UIEdgeInsets(top: 0.0, left: -4.0, bottom: 8.0, right: 0.0)
            contentTextView.delegate        =   self
            
            contentTextView.placeholder     =   (sceneType == .create ? "Enter Text Placeholder" : "Enter Comment Placeholder").localized()
            
            contentTextView.tune(textColors:    darkGrayWhiteColorPickers,
                                 font:          UIFont(name: "SFUIDisplay-Regular", size: 13.0 * widthRatio),
                                 alignment:     .left)
        }
    }
    
    @IBOutlet var sceneViewsCollection: [UIView]!
    
    @IBOutlet weak var stackViewTopConstraint: NSLayoutConstraint!
    @IBOutlet weak var contentViewBottomConstraint: NSLayoutConstraint!

    // Use with keyboard hide/show
    @IBOutlet weak var tagsViewBottomConstraint: NSLayoutConstraint!
    
    @IBOutlet weak var containerViewHeightConstraint: NSLayoutConstraint! {
        didSet {
            containerViewHeightConstraint.constant = 48.0 * heightRatio
        }
    }
    
    @IBOutlet var heightsCollection: [NSLayoutConstraint]! {
        didSet {
            _ = heightsCollection.map({ $0.constant *= heightRatio })
        }
    }
    
    @IBOutlet var widthsCollection: [NSLayoutConstraint]! {
        didSet {
            _ = widthsCollection.map({ $0.constant *= widthRatio })
        }
    }
    

    // MARK: - Class Initialization
    override init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?) {
        super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil)
        
        setup()
    }
    
    required init?(coder aDecoder: NSCoder) {
        super.init(coder: aDecoder)
        
        setup()
    }

    deinit {
        Logger.log(message: "Success", event: .severe)
    }
    
    
    // MARK: - Setup
    private func setup() {
        let viewController          =   self
        let interactor              =   PostCreateInteractor()
        let presenter               =   PostCreatePresenter()
        let router                  =   PostCreateRouter()
        
        viewController.interactor   =   interactor
        viewController.router       =   router
        interactor.presenter        =   presenter
        presenter.viewController    =   viewController
        router.viewController       =   viewController
        router.dataStore            =   interactor
    }
    
    
    // MARK: - Routing
    override func prepare(for segue: UIStoryboardSegue, sender: Any?) {
        if segue.identifier == "routeToTagsViewControllerWithSegue" {
            self.tagsVC = segue.destination as! TagsCollectionViewController
            
            // Handler change frame
            tagsVC.complationCollectionViewChangeHeight = { [weak self] height in
                self?.containerViewHeightConstraint.constant = height
            }
            
            // Handler start editing tags
            tagsVC.completionStartEndEditing = { [weak self] (constant, maxY) in
                self?.firstResponder        =   constant == 0.0 ? self?.view : self?.tagsVC.view
                
                // End editing
                if constant == 0.0 {
                    self?.containerViewHeightConstraint.constant = maxY! + 18.0 * heightRatio
                }
                
                self?.setConstraint()
            }
            
            // Handler change tags
            tagsVC.completionTagsChanged = { [weak self] in
                self?.interactor?.save(tags: self?.tagsVC.tags)
            }
        }
        
        if let scene = segue.identifier {
            let selector = NSSelectorFromString("routeTo\(scene)WithSegue:")
            
            if let router = router, router.responds(to: selector) {
                router.perform(selector, with: segue)
            }
        }
    }
    
    
    // MARK: - Class Functions
    override func viewDidLayoutSubviews() {
        super.viewDidLayoutSubviews()
        Logger.log(message: "Success", event: .severe)
        
        self.setConstraint()
    }

    override func viewDidLoad() {
        super.viewDidLoad()
        
        self.view.tune()
        
        sceneType = .create
        
        IQKeyboardManager.sharedManager().enable = false
    }
    
    override func viewWillAppear(_ animated: Bool) {
        super.viewWillAppear(animated)
        
        self.navigationController?.add(shadow: false, withBarTintColor: .white)
        self.navigationController?.hidesBarsOnTap   =   false

        self.contentTextView.layoutManager.ensureLayout(for: self.contentTextView.textContainer)
    }
    
    
    // MARK: - Custom Functions
    private func saveToAlbum(image: UIImage) {
        if let imageData = UIImageJPEGRepresentation(image, 0.6), let compressedJPGImage = UIImage(data: imageData) {
            UIImageWriteToSavedPhotosAlbum(compressedJPGImage, nil, nil, nil)
            
            self.showAlertView(withTitle: "Info", andMessage: "Image saved to Photo Library", needCancel: false, completion: { [weak self] _ in
                self?.contentTextView.add(object: image)
            })
        }
    }

    @objc private func image(path: String, didFinishSavingWithError error: NSError?, contextInfo: UnsafeMutableRawPointer?) {
        print(path) // That's the path you want
    }
    
    private func setConstraint() {
        let isKeyboardShow = IQKeyboardManager.sharedManager().keyboardShowing || self.isKeyboardShow
        
        if UIApplication.shared.statusBarOrientation.isPortrait {
            self.tagsViewBottomConstraint.constant = (isKeyboardShow ? (firstResponder == contentTextView ? 210.0 : 150.0) : (firstResponder == tagsVC.view ? 150.0 : 16.0)) * heightRatio
        }

        else {
            self.tagsViewBottomConstraint.constant = (isKeyboardShow ? 100.0 : 16.0) * heightRatio
        }
    }
    
    private func isRequestAvailable() -> Bool {
        // Check title
        if sceneType == .create && (self.postCreateView.titleTextField.text?.isEmpty)! {
            self.showAlertView(withTitle: "Info", andMessage: "Create Post Title Hint", needCancel: false, completion: { _ in })
            return false
        }
        
        // Check text body
        else if self.contentTextView.text.isEmpty {
            self.showAlertView(withTitle: "Info", andMessage: "Post Text Body Hint", needCancel: false, completion: { _ in })
            return false
        }
        
        // Check tags
        else if self.router?.dataStore?.tags == nil || self.router?.dataStore?.tags?.first?.title == nil  {
            self.showAlertView(withTitle: "Info", andMessage: "Select topic", needCancel: false, completion: { _ in })
            return false
        }
        
        // Check network connection
        guard isNetworkAvailable else {
            self.showAlertView(withTitle: "Info", andMessage: "No Internet Connection", needCancel: false, completion: { _ in })
            return false
        }
        
        self.interactor?.save(commentBody: self.contentTextView.text!)
        self.interactor?.save(commentTitle: self.postCreateView.titleTextField.text!)
        
        return true
    }
    
    private func changeTagsTitle(withCount count: Int) {
        self.tagsTitleLabel.text = String(format: "")
    }
    
    private func clearAllEnteredValues() {
        self.contentTextView.text                   =   nil
        self.postCreateView.titleTextField.text     =   nil
        self.commentReplyView.commentLabel.text     =   nil
        self.tagsVC.tags                            =   nil
        self.tagsVC.collectionView.reloadData()
        
        self.interactor?.save(tags: nil)
    }
    
    
    // MARK: - Actions
    @IBAction func cancelBarButtonTapped(_ sender: UIBarButtonItem) {
        self.clearAllEnteredValues()
        self.router?.routeToMainScene()
    }
    
    @IBAction func publishBarButtonTapped(_ sender: UIBarButtonItem) {
        guard isRequestAvailable() else {
            return
        }
        
        // API's
        switch sceneType {
        case .create:
            // Get content parts
            let contentParts    =   self.contentTextView.getParts()
                        
            self.interactor?.save(attachments: contentParts)

            let postCreateRequestModel = PostCreateModels.Post.RequestModel()
            interactor?.postCreate(withRequestModel: postCreateRequestModel)

        case .comment:
            // TODO: - ADD API
            self.showAlertView(withTitle: "Info", andMessage: "In development", needCancel: false, completion: { _ in })
//            let postCommentRequestModel = PostCreateModels.Something.RequestModel()
//            interactor?.postComment(withRequestModel: postCommentRequestModel)

        case .reply:
            // TODO: - ADD API
            self.showAlertView(withTitle: "Info", andMessage: "In development", needCancel: false, completion: { _ in })
//            let postCommentReplyRequestModel = PostCreateModels.Something.RequestModel()
//            interactor?.postCommentReply(withRequestModel: postCommentReplyRequestModel)
        }
    }
}


// MARK: - PostCreateDisplayLogic
extension PostCreateViewController: PostCreateDisplayLogic {
    func displayPostCreate(fromViewModel viewModel: PostCreateModels.Post.ViewModel) {
        // NOTE: Display the result from the Presenter
        guard viewModel.errorAPI == nil || viewModel.errorAPI?.caseInfo.message == "Result not found" else {
            let message = viewModel.errorAPI!.caseInfo.message.contains("You may only post once every 5 minutes") ? "You may only post once every 5 minutes" : viewModel.errorAPI!.caseInfo.message
            
            self.showAlertView(withTitle: viewModel.errorAPI!.caseInfo.title, andMessage: message, needCancel: false, completion: { _ in })
            return
        }
        
        self.clearAllEnteredValues()

        self.showAlertView(withTitle: "Info", andMessage: "Send Post Success", needCancel: false, completion: { [weak self] _ in
            self?.router?.routeToMainScene()
        })
    }
    
    func displayPostComment(fromViewModel viewModel: PostCreateModels.Post.ViewModel) {
        // NOTE: Display the result from the Presenter

        // TODO: - ADD IF VIEWMODEL SUCCESS = ROUTE TO NEW POST SCENE
    }
    
    func displayPostCommentReply(fromViewModel viewModel: PostCreateModels.Post.ViewModel) {
        // NOTE: Display the result from the Presenter

        // TODO: - ADD IF VIEWMODEL SUCCESS = ROUTE TO NEW POST SCENE
    }
}


// MARK: - UITextViewDelegate
extension PostCreateViewController: UITextViewDelegate {
    @available(iOS 10.0, *)
    func textView(_ textView: UITextView, shouldInteractWith textAttachment: NSTextAttachment, in characterRange: NSRange, interaction: UITextItemInteraction) -> Bool {
        return true
    }
    
    func textView(_ textView: UITextView, shouldChangeTextIn range: NSRange, replacementText text: String) -> Bool {
        return true
    }
    
    func textViewDidBeginEditing(_ textView: UITextView) {
        textView.theme_textColor    =   blackWhiteColorPickers
        self.firstResponder         =   self.contentTextView
        
        self.setConstraint()
    }
    
    func textViewDidEndEditing(_ textView: UITextView) {
        self.setConstraint()
    }

    func textViewShouldBeginEditing(_ textView: UITextView) -> Bool {
        self.contentTextView.showToolbar { [weak self] tag in
            textView.resignFirstResponder()
            
            switch tag {
            // Add link
            case 7:
                let linkAlert = UIAlertController(title: "Add Link Title".localized(), message: nil, preferredStyle: .alert)

                // Text
                linkAlert.addTextField { (textField) in
                    textField.placeholder = "Enter your text".localized()
                    textField.borderStyle = .none
                }

                // Link
                linkAlert.addTextField { (textField) in
                    textField.placeholder = "Enter your link".localized()
                    textField.borderStyle = .none
                }

                let actionOk = UIAlertAction(title: "ActionOk".localized(), style: .default) { [unowned linkAlert] _ in
                    guard let linkKey = linkAlert.textFields![0].text, !linkKey.isEmpty else {
                        return
                    }
                    
                    guard let linkPath = linkAlert.textFields![1].text, !linkPath.isEmpty else {
                        return
                    }
                    
                    // Add (linkName, linkURL)
                    self?.contentTextView.add(object: (linkKey.replacingOccurrences(of: " ", with: "_"), linkPath))
                }
                
                linkAlert.addAction(actionOk)
                self?.present(linkAlert, animated: true)
                
            // Add image
            case 8:
                let photoAlert = UIAlertController(title: nil, message: nil, preferredStyle: .actionSheet)
                
                photoAlert.addAction(UIAlertAction(title: "Take Photo Title".localized(), style: .default, handler: { _ in
                    if UIImagePickerController.isSourceTypeAvailable(.camera) {
                        let imagePicker             =   UIImagePickerController()
                        imagePicker.delegate        =   self
                        imagePicker.sourceType      =   .camera
                        imagePicker.allowsEditing   =   true
                        
                        textView.resignFirstResponder()
                        
                        self?.present(imagePicker, animated: true, completion: nil)
                    }
                    
                    else {
                        self?.showAlertView(withTitle: "Error", andMessage: "Camera is not available", needCancel: false, completion: { _ in
                            self?.contentTextView.becomeFirstResponder()
                        })
                    }
                }))

                photoAlert.addAction(UIAlertAction(title: "Open Photo Title".localized(), style: .default, handler: { _ in
                    if UIImagePickerController.isSourceTypeAvailable(.photoLibrary) {
                        let imagePicker             =   UIImagePickerController()
                        imagePicker.delegate        =   self
                        imagePicker.sourceType      =   .photoLibrary
                        imagePicker.allowsEditing   =   true
                        
                        self?.present(imagePicker, animated: true, completion: nil)
                    }
                    
                    else {
                        self?.showAlertView(withTitle: "Error", andMessage: "Album is not available", needCancel: false, completion: { _ in })
                    }
                }))
                
                photoAlert.addAction(UIAlertAction(title: "ActionCancel".localized(), style: .destructive))
                
                photoAlert.popoverPresentationController?.barButtonItem = self?.navigationItem.rightBarButtonItem
                
                self?.present(photoAlert, animated: true)
                
            default:
                self?.setConstraint()
            }
        }
        
        return true
    }
}


// MARK: - UINavigationControllerDelegate
extension PostCreateViewController: UINavigationControllerDelegate {
    func navigationController(_ navigationController: UINavigationController, didShow viewController: UIViewController, animated: Bool) {
        navigationController.navigationBar.add(shadow: true, onside: .bottom)
    }
}


// MARK: - UIImagePickerControllerDelegate
extension PostCreateViewController: UIImagePickerControllerDelegate {
    func imagePickerController(_ picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [String: Any]) {
        picker.dismiss(animated: true)
        
        guard let image = info[UIImagePickerControllerEditedImage] as? UIImage else {
            showAlertView(withTitle: "Error", andMessage: "No image found", needCancel: false, completion: { _ in })

            return
        }

        if picker.sourceType == .camera {
            self.saveToAlbum(image: image)
        }
        
        else {
            self.contentTextView.add(object: image)
        }
    }
}
