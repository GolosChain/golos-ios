//
//  PostShowViewController.swift
//  golos-ios
//
//  Created by msm72 on 31.07.2018.
//  Copyright (c) 2018 golos. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit
import WebKit
import CoreData
import GoloSwift
import SafariServices
import Localize_Swift
import AlignedCollectionViewFlowLayout

// MARK: - Input & Output protocols
protocol PostShowDisplayLogic: class {
    func displaySubscribe(fromViewModel viewModel: PostShowModels.Item.ViewModel)
    func displayLoadPostContent(fromViewModel viewModel: PostShowModels.Post.ViewModel)
    func displayLoadPostComments(fromViewModel viewModel: PostShowModels.Post.ViewModel)
    func displayCheckFollowing(fromViewModel viewModel: PostShowModels.Following.ViewModel)
    func displayLikeVote(fromViewModel viewModel: PostShowModels.Like.ViewModel)
}

class PostShowViewController: GSBaseViewController {
    // MARK: - Properties
    var insertedRow: Int?
    var tagsWidth: CGFloat = 0.0
    var scrollCommentsDown: Bool = false
    var permlinkCreatedItem: String = ""
    var isPostContentModify: Bool = false
    
    var loadPostContentWorkItem: DispatchWorkItem!
    var loadPostCommentsWorkItem: DispatchWorkItem!
    var runCheckFollowingWorkItem: DispatchWorkItem!

    var comments: [Comment]?
    var commentViews: [CommentView]?
    
    // Comments pagination
    let paginationOffset    =   5
    var isPaginationRun     =   false
    var needPagination      =   false
    
    var gsTimer: GSTimer?
    
    var interactor: PostShowBusinessLogic?
    var router: (NSObjectProtocol & PostShowRoutingLogic & PostShowDataPassing)?
    
    // Handlers
    var handlerPostShowSceneClose: ((Bool) -> Void)?

    
    // MARK: - IBOutlets
    @IBOutlet weak var postFeedHeaderView: PostFeedHeaderView!
    @IBOutlet weak var commentsControlView: UIView!
    @IBOutlet weak var subscribesStackView: UIStackView!
    @IBOutlet weak var postFeedHeaderViewHeightConstraint: NSLayoutConstraint!
    
    @IBOutlet weak var createNewCommentView: UIView! {
        didSet {
            self.createNewCommentView.tune()
        }
    }
    
    @IBOutlet weak var placeholderButton: UIButton! {
        didSet {
            self.placeholderButton.tune(withTitle:     "",
                                        hexColors:     [darkGrayWhiteColorPickers, lightGrayWhiteColorPickers, lightGrayWhiteColorPickers, lightGrayWhiteColorPickers],
                                        font:          UIFont(name: "SFProDisplay-Regular", size: 14.0),
                                        alignment:     .left)
        }
    }
    
    @IBOutlet weak var commentsStackView: UIStackView! {
        didSet {
            self.commentsStackView.alpha = 0.0
        }
    }
    
    @IBOutlet weak var infiniteScrollingView: UIView! {
        didSet {
            self.infiniteScrollingView.tune()
            self.infiniteScrollingView.alpha = 0.0
        }
    }
    
    @IBOutlet weak var loadingPostContentActivityIndicator: UIActivityIndicatorView! {
        didSet {
            DispatchQueue.main.asyncAfter(deadline: DispatchTime.now() + 0.1) {
                self.loadingPostContentActivityIndicator.startAnimating()
            }
        }
    }
    
    @IBOutlet weak var likeActivityIndicator: UIActivityIndicatorView! {
        didSet {
            self.likeActivityIndicator.stopAnimating()
        }
    }
    
    @IBOutlet weak var dislikeActivityIndicator: UIActivityIndicatorView! {
        didSet {
            self.dislikeActivityIndicator.stopAnimating()
        }
    }
    
    @IBOutlet var hiddenViewsCollection: [UIView]! {
        didSet {
            self.hiddenViewsCollection.forEach({ $0.alpha = 0.0 })
        }
    }
    
    @IBOutlet weak var subscribeActivityIndicator: UIActivityIndicatorView! {
        didSet {
            self.subscribeActivityIndicator.stopAnimating()
        }
    }
    
    @IBOutlet weak var scrollView: UIScrollView! {
        didSet {
            self.scrollView.delegate = self
        }
    }
    
    @IBOutlet weak var markdownViewManager: MarkdownViewManager! {
        didSet {
            // Handler Markdown
            markdownViewManager.completionErrorAlertView            =   { [weak self] errorMessage in
                self?.showAlertView(withTitle: "Error", andMessage: errorMessage, needCancel: false, completion: { _ in })
            }
            
            markdownViewManager.completionCommentAuthorTapped       =   { [weak self] authorName in
                self?.router?.routeToUserProfileScene(byUserName: authorName)
            }
            
            markdownViewManager.completionShowSafariURL             =   { [weak self] url in
                self?.openExternalLink(byURL: url.absoluteString)
            }
        }
    }

    @IBOutlet weak var tagsCollectionView: UICollectionView! {
        didSet {
            tagsCollectionView.register(UINib(nibName:               "PostShowTagCollectionViewCell", bundle: nil),
                                        forCellWithReuseIdentifier:  "PostShowTagCollectionViewCell")
            
            tagsCollectionView.tune()
            tagsCollectionView.delegate     =   self
            tagsCollectionView.dataSource   =   self
            
            tagsCollectionView.collectionViewLayout = AlignedCollectionViewFlowLayout.init(horizontalAlignment: .left, verticalAlignment: .top)
        }
    }
    
    @IBOutlet weak var contentView: UIView! {
        didSet {
            contentView.tune()
        }
    }
    
    @IBOutlet weak var navbarView: UIView! {
        didSet {
            navbarView.tune()
        }
    }
    
    @IBOutlet weak var titleLabel: UILabel! {
        didSet {
            titleLabel.tune(withText:           "",
                            hexColors:          veryDarkGrayWhiteColorPickers,
                            font:               UIFont(name: "SFProDisplay-Medium", size: 15.0),
                            alignment:          .left,
                            isMultiLines:       true)
        }
    }
    
    @IBOutlet weak var likeButton: UIButton! {
        didSet {
            likeButton.isEnabled = true
        }
    }

    @IBOutlet weak var likeCountButton: UIButton! {
        didSet {
            likeCountButton.tune(withTitle:     "",
                                 hexColors:     [veryDarkGrayWhiteColorPickers, lightGrayWhiteColorPickers, lightGrayWhiteColorPickers, lightGrayWhiteColorPickers],
                                 font:          UIFont(name: "SFProDisplay-Regular", size: 12.0),
                                 alignment:     .left)
            
            likeCountButton.isEnabled = true
        }
    }

    @IBOutlet weak var dislikeButton: UIButton! {
        didSet {
            dislikeButton.isEnabled = true
        }
    }
    
    @IBOutlet weak var dislikeCountButton: UIButton! {
        didSet {
            dislikeCountButton.tune(withTitle:      "",
                                    hexColors:      [veryDarkGrayWhiteColorPickers, lightGrayWhiteColorPickers, lightGrayWhiteColorPickers, lightGrayWhiteColorPickers],
                                    font:           UIFont(name: "SFProDisplay-Regular", size: 12.0),
                                    alignment:      .center)
            
            dislikeCountButton.isEnabled = true
        }
    }
    
    @IBOutlet weak var repostButton: UIButton! {
        didSet {
            repostButton.tune(withTitle:        "    ",
                             hexColors:         [veryDarkGrayWhiteColorPickers, lightGrayWhiteColorPickers, lightGrayWhiteColorPickers, lightGrayWhiteColorPickers],
                             font:              UIFont(name: "SFProDisplay-Regular", size: 12.0),
                             alignment:         .center)
            
            repostButton.isEnabled = false
        }
    }
    
    @IBOutlet weak var commentsButton: UIButton! {
        didSet {
            commentsButton.tune(withTitle:      "    ",
                                hexColors:      [veryDarkGrayWhiteColorPickers, lightGrayWhiteColorPickers, lightGrayWhiteColorPickers, lightGrayWhiteColorPickers],
                                font:           UIFont(name: "SFProDisplay-Regular", size: 10.0),
                                alignment:      .center)
            
            commentsButton.isEnabled = true
        }
    }
    
    @IBOutlet weak var promoteButton: UIButton! {
        didSet {
            promoteButton.tune(withTitle:       "Promote Post Verb",
                               hexColors:       [veryDarkGrayWhiteColorPickers, lightGrayWhiteColorPickers, lightGrayWhiteColorPickers, lightGrayWhiteColorPickers],
                               font:            UIFont(name: "SFProDisplay-Medium", size: 11.0),
                               alignment:       .center)
            
            promoteButton.isEnabled = false
            
            promoteButton.setBorder(color: UIColor(hexString: "#6ad381").cgColor, cornerRadius: 4.0 * heightRatio)
        }
    }
    
    @IBOutlet weak var donateButton: UIButton! {
        didSet {
            donateButton.tune(withTitle:        "Donate Verb",
                               hexColors:        [veryDarkGrayWhiteColorPickers, lightGrayWhiteColorPickers, lightGrayWhiteColorPickers, lightGrayWhiteColorPickers],
                               font:             UIFont(name: "SFProDisplay-Medium", size: 11.0),
                               alignment:        .center)
            
            donateButton.isEnabled = true
           
            donateButton.setBorder(color: UIColor(hexString: "#6ad381").cgColor, cornerRadius: 4.0 * heightRatio)
        }
    }
    
    // Subscribe by Topic
    @IBOutlet weak var topicCoverImageView: UIImageView!
    
    @IBOutlet weak var topicPublishedInLabel: UILabel! {
        didSet {
            topicPublishedInLabel.tune(withText:         "Published in",
                                       hexColors:        darkGrayWhiteColorPickers,
                                       font:             UIFont(name: "SFProDisplay-Regular", size: 8.0),
                                       alignment:        .left,
                                       isMultiLines:     false)
        }
    }
    
    @IBOutlet weak var topicTitleLabel: UILabel! {
        didSet {
            topicTitleLabel.tune(withText:         "",
                                 hexColors:        darkGrayWhiteColorPickers,
                                 font:             UIFont(name: "SFProDisplay-Regular", size: 12.0),
                                 alignment:        .left,
                                 isMultiLines:     false)
        }
    }
    
    // Subscribe by User
    @IBOutlet weak var userAvatarImageView: UIImageView!
    
    @IBOutlet weak var userNameLabel: UILabel! {
        didSet {
            userNameLabel.tune(withText:            "",
                               hexColors:           veryDarkGrayWhiteColorPickers,
                               font:                UIFont(name: "SFProDisplay-Regular", size: 12.0),
                               alignment:           .left,
                               isMultiLines:        false)
        }
    }
    
    @IBOutlet weak var userRecentPastLabel: UILabel! {
        didSet {
            userRecentPastLabel.tune(withText:      "Recent Past:",
                                     hexColors:     darkGrayWhiteColorPickers,
                                     font:          UIFont(name: "SFProDisplay-Regular", size: 8.0),
                                     alignment:     .left,
                                     isMultiLines:  false)
        }
    }
    
    @IBOutlet weak var userPreviouslyLabel: UILabel! {
        didSet {
            userPreviouslyLabel.tune(withText:      "Previously:",
                                     hexColors:     darkGrayWhiteColorPickers,
                                     font:          UIFont(name: "SFProDisplay-Regular", size: 8.0),
                                     alignment:     .left,
                                     isMultiLines:  false)
        }
    }

    @IBOutlet var subscribeUserButton: UIButton! {
        didSet {
            self.subscribeUserButton.tune(withTitle:    "",
                                          hexColors:    [veryDarkGrayWhiteColorPickers, lightGrayWhiteColorPickers, veryDarkGrayWhiteColorPickers, lightGrayWhiteColorPickers],
                                          font:         UIFont(name: "SFProDisplay-Medium", size: 10.0),
                                          alignment:    .center)
            
            self.subscribeUserButton.fill(font: UIFont(name: "SFProDisplay-Medium", size: 10.0)!)
        }
    }
    
    @IBOutlet weak var bottomLineView: UIView! {
        didSet {
            bottomLineView.tune(withThemeColorPicker: veryLightGrayColorPickers)
        }
    }
    
    @IBOutlet var backgroundGrayViewsCollection: [UIView]! {
        didSet {
            self.backgroundGrayViewsCollection.forEach({ $0.theme_backgroundColor = veryLightGrayColorPickers })
        }
    }
    
    @IBOutlet weak var commentsTitleLabel: UILabel! {
        didSet {
            commentsTitleLabel.tune(withText:           "Comments Noun",
                                    hexColors:          veryDarkGrayWhiteColorPickers,
                                    font:               UIFont(name: "SFProDisplay-Regular", size: 14.0),
                                    alignment:          .left,
                                    isMultiLines:       false)
        }
    }

    @IBOutlet weak var commentsCountLabel: UILabel! {
        didSet {
            commentsCountLabel.tune(withText:           "",
                                    hexColors:          grayWhiteColorPickers,
                                    font:               UIFont(name: "SFProDisplay-Regular", size: 14.0),
                                    alignment:          .left,
                                    isMultiLines:       false)
        }
    }

    @IBOutlet weak var sortByLabel: UILabel! {
        didSet {
            sortByLabel.tune(withText:           "Sort by",
                             hexColors:          grayWhiteColorPickers,
                             font:               UIFont(name: "SFProDisplay-Regular", size: 10.0),
                             alignment:          .left,
                             isMultiLines:       false)
        }
    }

    @IBOutlet weak var commentsSortByButton: UIButton! {
        didSet {
            commentsSortByButton.tune(withTitle:        "Action Sheet First New",
                                      hexColors:        [veryDarkGrayWhiteColorPickers, lightGrayWhiteColorPickers, lightGrayWhiteColorPickers, lightGrayWhiteColorPickers],
                                      font:             UIFont(name: "SFProDisplay-Regular", size: 10.0),
                                      alignment:        .center)
            
            commentsSortByButton.isEnabled  =   true
        }
    }

    @IBOutlet weak var commentsHideButton: UIButton! {
        didSet {
            commentsHideButton.tune(withTitle:        "Hide Comments Verb",
                                    hexColors:        [veryDarkGrayWhiteColorPickers, lightGrayWhiteColorPickers, veryDarkGrayWhiteColorPickers, lightGrayWhiteColorPickers],
                                    font:             UIFont(name: "SFProDisplay-Medium", size: 8.0),
                                    alignment:        .center)
            
            commentsHideButton.isEnabled    =   true
            commentsHideButton.setBorder(color: UIColor(hexString: "#dbdbdb").cgColor, cornerRadius: 4.0 * heightRatio)
        }
    }
    
    // Collections
    @IBOutlet var circleImagesCollection: [UIView]! {
        didSet {
            circleImagesCollection.forEach({ imageView in
                imageView.layer.cornerRadius = imageView.bounds.width / 2 * widthRatio
                
                if imageView.tag == 0 {
                    imageView.layer.borderWidth     =   1.0
                    imageView.layer.borderColor     =   UIColor(hexString: "#1e1e1e").cgColor
                }
            })
        }
    }
    
    @IBOutlet var heightsCollection: [NSLayoutConstraint]! {
        didSet {
            self.heightsCollection.forEach({ $0.constant *= heightRatio })
        }
    }
    
    @IBOutlet var widthsCollection: [NSLayoutConstraint]! {
        didSet {
            self.widthsCollection.forEach({ $0.constant *= widthRatio })
        }
    }
    
    @IBOutlet weak var buttonsStackViewTopConstraint: NSLayoutConstraint! {
        didSet {
            buttonsStackViewTopConstraint.constant = -34.0 * heightRatio * 0.0
        }
    }
    
    @IBOutlet weak var contentViewTopConstraint: NSLayoutConstraint! {
        didSet {
            self.contentViewTopConstraint.constant = 52.0 * heightRatio
        }
    }
    
    @IBOutlet weak var infiniteScrollingViewBottomConstraint: NSLayoutConstraint! {
        didSet {
            self.infiniteScrollingViewBottomConstraint.constant = -44.0 * heightRatio
        }
    }

    @IBOutlet weak var tagsCollectionViewheightConstraint: NSLayoutConstraint!
    @IBOutlet weak var markdownViewHeightConstraint: NSLayoutConstraint!
    @IBOutlet weak var commentsControlViewTopConstraint: NSLayoutConstraint!
    @IBOutlet weak var subscribesStackViewTopConstraint: NSLayoutConstraint!
    @IBOutlet weak var commentsStackViewHeightConstraint: NSLayoutConstraint!
    @IBOutlet weak var commentsStackViewTopConstraint: NSLayoutConstraint!
    
    
    // MARK: - Class Initialization
    override init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?) {
        super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil)
        
        setup()
    }
    
    required init?(coder aDecoder: NSCoder) {
        super.init(coder: aDecoder)
        
        setup()
    }

    deinit {
        Logger.log(message: "Success", event: .severe)
    }
    
    
    // MARK: - Setup
    private func setup() {
        let viewController          =   self
        let interactor              =   PostShowInteractor()
        let presenter               =   PostShowPresenter()
        let router                  =   PostShowRouter()
        
        viewController.interactor   =   interactor
        viewController.router       =   router
        interactor.presenter        =   presenter
        presenter.viewController    =   viewController
        router.viewController       =   viewController
        router.dataStore            =   interactor
    }
    
    
    // MARK: - Routing
    override func prepare(for segue: UIStoryboardSegue, sender: Any?) {
        Logger.log(message: "Success", event: .severe)
        
        if let scene = segue.identifier {
            let selector = NSSelectorFromString("routeTo\(scene)WithSegue:")
            
            if let router = router, router.responds(to: selector) {
                router.perform(selector, with: segue)
            }
        }
    }
    
    
    // MARK: - Class Functions
    override func viewDidLoad() {
        super.viewDidLoad()
        Logger.log(message: "Success", event: .severe)

        // Handlers
        self.postFeedHeaderView.handlerAuthorTapped         =   { [weak self] userName in
            self?.router?.routeToUserProfileScene(byUserName: userName)
        }
   
        self.postFeedHeaderView.handlerPostAuthorTapped   =   { [weak self] reblogAuthorName in
            self?.router?.routeToUserProfileScene(byUserName: reblogAuthorName)
        }
        
        if let user = User.current {
            let isNamesMatch = user.nickName == self.router?.dataStore?.postShortInfo?.author
            
            self.subscribesStackViewTopConstraint.constant = isNamesMatch ? -100.0 * heightRatio : 0.0
            self.backgroundGrayViewsCollection.first(where: { $0.tag == 0 })?.isHidden = isNamesMatch
            self.contentView.bringSubviewToFront(self.backgroundGrayViewsCollection.first(where: { $0.tag == 1 })!)
            
            UIView.animate(withDuration: 0.3) {
                self.subscribesStackView.isHidden = isNamesMatch
                self.view.layoutIfNeeded()
            }
        }
    }
    
    override func viewWillAppear(_ animated: Bool) {
        super.viewWillAppear(animated)
        Logger.log(message: "Success", event: .severe)

        self.localizeTitles()
        self.hideNavigationBar()
        
        // Set StatusBarStyle
        self.isStatusBarStyleLight = false
    }
    
    override func viewWillDisappear(_ animated: Bool) {
        super.viewWillDisappear(animated)

        if let contentWorkItem = self.loadPostContentWorkItem, !contentWorkItem.isCancelled {
            contentWorkItem.cancel()
        }
        
        if let commentsWorkItem = self.loadPostCommentsWorkItem, !commentsWorkItem.isCancelled {
            commentsWorkItem.cancel()
        }
        
        if let followingWorkItem = self.runCheckFollowingWorkItem, !followingWorkItem.isCancelled {
            followingWorkItem.cancel()
        }
    }

    
    // MARK: - Custom Functions
    private func didCommentsControlView(hided: Bool) {
        Logger.log(message: "Success", event: .severe)

        self.commentsControlViewTopConstraint.constant          =   heightRatio * (hided ? -70.0 : 0.0)
        self.commentsControlView.isHidden                       =   hided
        
        // Hide loading activity interactior
        self.loadingPostContentActivityIndicator.stopAnimating()
        self.contentViewTopConstraint.constant = 0.0
        
        UIView.animate(withDuration: 0.3) {
            self.view.layoutIfNeeded()
            self.commentsStackView.alpha    =   1.0
        }
        
        if self.scrollCommentsDown {
            self.didContentViewScrollToCommentsView()
        }
    }
    
    private func loadViewSettings(withoutComments: Bool) {
        Logger.log(message: "Success", event: .severe)

        if let displayedPost = self.router?.dataStore?.displayedPost {
            self.likeButton.isEnabled       =   true
            self.dislikeButton.isEnabled    =   true

            self.likeActivityIndicator.stopAnimating()
            self.dislikeActivityIndicator.stopAnimating()

            // Like icon
            self.likeButton.tag = displayedPost.currentUserLiked ? 99 : 0
            self.likeCountButton.setTitle(displayedPost.likeCount > 0 ? "\(displayedPost.likeCount)" : nil, for: .normal)
            self.likeButton.setImage(UIImage(named: displayedPost.currentUserLiked ? "icon-button-post-like-selected" : "icon-button-post-like-normal"), for: .normal)
            
            // Dislike icon
            self.dislikeButton.tag = displayedPost.currentUserDisliked ? 99 : 0
            self.dislikeCountButton.setTitle(displayedPost.dislikeCount > 0 ? "\(displayedPost.dislikeCount)" : nil, for: .normal)
            self.dislikeButton.setImage(displayedPost.currentUserDisliked ? UIImage(named: "icon-button-post-dislike-selected") : UIImage(named: "icon-button-post-dislike-normal"), for: .normal)
            
            // Comments icon
            self.commentsButton.setTitle(displayedPost.children > 0 ? "\(displayedPost.children)" : "    ", for: .normal)
            self.commentsButton.setImage(UIImage(named: displayedPost.currentUserCommented ? "icon-button-post-comments-selected" : "icon-button-post-comments-normal"), for: .normal)

            // Create new comment placeholder
            self.placeholderButton.setTitle((displayedPost.children == 0  ? "No Comments Placeholder" : "Write Own Comment Placeholder").localized(), for: .normal)
            
            if !withoutComments {
                self.postFeedHeaderView.display(post: displayedPost, inNavBar: true, completion: { _ in })
                
                self.markdownViewManager.load(markdown: Parser.repair(body: displayedPost.body))

                self.markdownViewManager.onRendered = { [weak self] height in
                    self?.markdownViewHeightConstraint.constant = height
                    
                    UIView.animate(withDuration: 0.5, animations: {
                        self?.hiddenViewsCollection.forEach({ $0.alpha = 1.0 })
                    })
                    
                    self?.gsTimer?.stop()
                    
                    // Load comments
                    self?.loadPostComments()
                }

                self.titleLabel.text = displayedPost.title
                
                DispatchQueue.main.asyncAfter(deadline: DispatchTime.now() + 0.1) {
                    self.tagsCollectionView.reloadData()
                }
                
                // Subscribe topic
                if let firstTag = displayedPost.tags?.first {
                    self.topicTitleLabel.text = firstTag.transliteration(forPermlink: false).uppercaseFirst
                }
                
                // Subscribe User
                if  let author = self.router?.dataStore?.postShortInfo?.author,
                    let user = User.fetch(byNickName: author), let userProfileImageURL = user.profileImageURL {
                    
                    self.userAvatarImageView.uploadImage(byStringPath:      userProfileImageURL,
                                                         imageType:         .userProfileImage,
                                                         size:              CGSize(width: 50.0, height: 50.0),
                                                         tags:              nil,
                                                         createdDate:       user.created.convert(toDateFormat: .expirationDateType),
                                                         fromItem:          (user as CachedImageFrom).fromItem,
                                                         completion:        { _ in })
                }
                
                self.userNameLabel.text = self.postFeedHeaderView.authorNameButton.titleLabel!.text
            }
        }
    }
    
    override func localizeTitles() {
        Logger.log(message: "Success", event: .severe)
        
        self.tagsCollectionView.reloadData()
        
        if let dataStore = self.router?.dataStore, dataStore.displayedPost != nil {
            self.postFeedHeaderView.display(post: dataStore.displayedPost!, inNavBar: true, completion: { _ in })
        }
        
        self.postFeedHeaderView.categoryLabel.text = self.router!.dataStore!.displayedPost!.category
                                                        .transliteration(forPermlink: false)
                                                        .uppercaseFirst
        
        self.donateButton.setTitle("Donate Verb".localized(), for: .normal)
        self.promoteButton.setTitle("Promote Post Verb".localized(), for: .normal)
        
        if self.comments == nil {
            self.placeholderButton.setTitle("No Comments Placeholder".localized(), for: .normal)
        }
        
        else {
            self.placeholderButton.setTitle("Write Own Comment Placeholder".localized(), for: .normal)

            // FIXME: - ADD LOCALIZE COMMENT CELLS
//            self.commentsTableView.reloadRows(at: self.commentsTableView.indexPathsForVisibleRows!, with: .none)
        }
        
        self.commentsHideButton.setTitle("Hide Comments Verb".localized(), for: .normal)
        self.commentsSortByButton.setTitle("Action Sheet First New".localized(), for: .normal)
        self.subscribeUserButton.setTitle((self.subscribeUserButton.isSelected ? "Subscriptions" : "Subscribe Verb").localized(), for: .normal)
        
        self.sortByLabel.text = "Sort by".localized()
        self.commentsTitleLabel.text = "Comments Noun".localized()
        self.userRecentPastLabel.text = "Recent Past:".localized()
        self.userPreviouslyLabel.text = "Previously:".localized()
        self.topicPublishedInLabel.text = "Published in".localized()
        
        if let topicTitle = self.router?.dataStore?.displayedPost?.tags?.first?.transliteration(forPermlink: false).uppercaseFirst {
            self.topicTitleLabel.text = topicTitle
        }
    }

    private func didContentViewScrollToCommentsView() {
        Logger.log(message: "Success", event: .severe)

        DispatchQueue.main.asyncAfter(deadline: DispatchTime.now() + 0.5, execute: {
            UIView.animate(withDuration:    0.1,
                           delay:           0.2,
                           options:         .transitionCrossDissolve,
                           animations:      {
                            let bottomViewFrame = self.backgroundGrayViewsCollection.first(where: { $0.tag == 1 })!.frame

                            guard self.comments != nil else {
                                self.scrollView.contentOffset.y = (self.commentsStackView.frame.maxY > self.view.frame.height) ? (64.0 + self.commentsStackView.frame.maxY - self.view.frame.height + self.createNewCommentView.frame.height) : self.createNewCommentView.frame.height
                                
                                return
                            }

                            // Scrolling after add new Comments item
                            if self.isPostContentModify {
                                let commentView = self.commentsStackView.arrangedSubviews[self.insertedRow ?? 0]
                                let commentViewFrame = self.contentView.convert(commentView.frame, from: self.commentsStackView)
                                self.scrollView.contentOffset.y = commentViewFrame.minY
                            }

                            // Scrolling down only once after open scene
                            else if self.scrollCommentsDown {
                                self.scrollView.contentOffset.y = bottomViewFrame.maxY
                                self.scrollCommentsDown = false
                            }
            })
        })
    }
    
    private func clearComments(byIndex index: Int) {
        // Clear Comment array
        let range = self.insertedRow!..<self.comments!.count
        self.comments?.removeSubrange(range)
        
        // Clear CommentView array
        let removedCommentView = Array(self.commentViews![range])
        self.commentViews?.removeSubrange(range)
        
        // Clear CommentsStackView
        removedCommentView.forEach({
            self.commentsStackView.removeArrangedSubview($0)
            self.commentsStackViewHeightConstraint.constant -= $0.frame.height
        })
        
        self.commentsStackView.layoutIfNeeded()
    }
    
    private func didFinishLoadComments(afterPagination isPaginationRun: Bool) {
        if isPaginationRun {
            DispatchQueue.main.asyncAfter(deadline: DispatchTime.now() + 2.5, execute: {
                self.isPaginationRun = false
                self.gsTimer?.stop()
                self.loadPostCommentsWorkItem.cancel()
                self.infiniteScrollingView.hide(constraint: self.infiniteScrollingViewBottomConstraint)
                
                self.clearProperties()
            })
        } else {
            self.clearProperties()
        }
    }
    
    private func clearProperties() {
        self.insertedRow = nil
        self.permlinkCreatedItem = ""
        self.didCommentsControlView(hided: false)
    }
    
    
    // MARK: - Actions
    @IBAction func backButtonTapped(_ sender: UIButton) {
        // Return comments count
        DispatchQueue.main.async {
            self.navigationController?.popViewController(animated: true)
            self.handlerPostShowSceneClose!(self.isPostContentModify)
        }
    }
    
    @IBAction func moreButtonTapped(_ sender: UIButton) {
        self.showAlertView(withTitle: "Info", andMessage: "In development", needCancel: false, completion: { _ in })
    }
    
    @IBAction func shareButtonTapped(_ sender: UIButton) {
        if isNetworkAvailable {
            let urlString   =   "https://www.google.com/any-link-to-share"
            let shareText   =   "Hello, world!"
            
            if let image = try! UIImage(data: Data(contentsOf: URL(string: "https://www.google.co.in/logos/doodles/2017/mohammed-rafis-93th-birthday-5885879699636224.2-l.png")!)) {
                let activityVC  =   UIActivityViewController(activityItems: [shareText, urlString, image], applicationActivities: nil)
                present(activityVC, animated: true, completion: nil)
                
                if let popover = activityVC.popoverPresentationController {
                    popover.sourceView  =   self.view
                }
            }
        }
        
        else {
            self.showAlertView(withTitle: "Info", andMessage: "No Internet Connection", needCancel: false, completion: { _ in })
        }
    }
    
    @IBAction func likeButtonTapped(_ sender: UIButton) {
        let isLike              =   sender.tag == 0
        let requestModel        =   PostShowModels.Like.RequestModel(isLike: sender.tag == 0, isDislike: nil, forPost: true)
        let handlersManager     =   HandlersManager()
        
        handlersManager.handlerTapped(isLike: isLike, completion: { [weak self] success in
            guard let result = success else {
                self?.likeButton.startLikeVote(withSpinner: (self?.likeActivityIndicator)!)
                self?.interactor?.likeVote(withRequestModel: requestModel)

                return
            }
            
            if result {
                self?.likeButton.startLikeVote(withSpinner: (self?.likeActivityIndicator)!)
                self?.interactor?.likeVote(withRequestModel: requestModel)
            }
                
            else {
                self?.likeButton.breakLikeVote(withSpinner: (self?.likeActivityIndicator)!)
            }
        })
    }

    @IBAction func likeCountButtonTapped(_ sender: UIButton) {
        DispatchQueue.main.async {
            self.router?.routeToActiveVotersShowScene(asPost: true, withMode: .like)
        }
    }
    
    @IBAction func dislikeButtonTapped(_ sender: UIButton) {
        let isDislike           =   sender.tag == 0
        let handlersManager     =   HandlersManager()
        
        handlersManager.handlerTapped(isDislike: isDislike, completion: { [weak self] success in
            if success {
                let requestModel = PostShowModels.Like.RequestModel(isLike: nil, isDislike: isDislike, forPost: true)
                
                self?.dislikeButton.startLikeVote(withSpinner: (self?.dislikeActivityIndicator)!)
                self?.interactor?.likeVote(withRequestModel: requestModel)
            }
                
            else {
                self?.dislikeButton.breakLikeVote(withSpinner: (self?.dislikeActivityIndicator)!)
            }
        })
    }
    
    @IBAction func dislikeCountButtonTapped(_ sender: UIButton) {
        DispatchQueue.main.async {
            self.router?.routeToActiveVotersShowScene(asPost: true, withMode: .dislike)
        }
    }
    
    @IBAction func repostButtonTapped(_ sender: UIButton) {
        self.showAlertView(withTitle: "Info", andMessage: "In development", needCancel: false, completion: { _ in })
    }

    @IBAction func commentsButtonTapped(_ sender: UIButton) {
        guard self.isCurrentOperationPossible() else { return }

//        self.isPostContentModify = true
//        self.insertedRow = 3
//
//        self.didContentViewScrollToCommentsView()
        
        DispatchQueue.main.async {
            self.router?.routeToPostCreateScene(withType: .createComment)
            self.insertedRow = self.comments?.filter({ $0.treeLevel == 0 }).count ?? 0
        }
    }

    @IBAction func promoteButtonTapped(_ sender: UIButton) {
        sender.layer.borderColor = UIColor(hexString: "#6ad381").cgColor

        self.showAlertView(withTitle: "Info", andMessage: "In development", needCancel: false, completion: { _ in })
    }

    @IBAction func donateButtonTapped(_ sender: UIButton) {
        sender.layer.borderColor = UIColor(hexString: "#6ad381").cgColor

        self.showAlertView(withTitle: "Info", andMessage: "In development", needCancel: false, completion: { _ in })
    }
    
    @IBAction func buttonsTappedDown(_ sender: UIButton) {
        sender.layer.borderColor = UIColor(hexString: "#dbdbdb").cgColor
    }

    @IBAction func sortCommentsByButtonTapped(_ sender: UIButton) {
        self.showAlertView(withTitle: "Info", andMessage: "In development", needCancel: false, completion: { _ in })
    }

    @IBAction func hideCommentsButtonTapped(_ sender: UIButton) {
        sender.isSelected = !sender.isSelected
        self.commentsStackViewTopConstraint.constant = self.commentsStackViewHeightConstraint.constant * (sender.isSelected ? -1 : 0)
        
        sender.setTitle("Hide Comments Verb".localized(), for: .normal)
        sender.setTitle("Show Comments Verb".localized(), for: .selected)
        
        UIView.animate(withDuration: 0.5) {
            self.commentsStackView.alpha = sender.isSelected ? 0.0 : 1.0
            self.view.layoutIfNeeded()
            
            // Scrolling to bottom
            if !sender.isSelected && self.scrollCommentsDown {
                self.didContentViewScrollToCommentsView()
            }
        }
    }
    
    @IBAction func userProfileImageButtonTapped(_ sender: UIButton) {
        self.postFeedHeaderView.profileAuthorButtonTapped(sender)
    }
   
    @IBAction func subscribeUserButtonTapped(_ sender: UIButton) {
        guard self.isCurrentOperationPossible() else { return }

        guard sender.isSelected else {
            // API 'Subscribe'
            let requestModel = PostShowModels.Item.RequestModel(willSubscribe: true)
            interactor?.subscribe(withRequestModel: requestModel)

            // Run spinner
            DispatchQueue.main.async {
                sender.setTitle(nil, for: .normal)
                self.subscribeActivityIndicator.startAnimating()
            }
            
            return
        }

        // API 'Unsibscribe'
        self.showAlertAction(withTitle: "Unsubscribe Verb", andMessage: String(format: "%@ @%@ ?", "Unsubscribe are you sure".localized(), self.postFeedHeaderView.authorNickNameButton.titleLabel!.text!.uppercaseFirst), icon: self.postFeedHeaderView.authorProfileImageView.image, actionTitle: "Cancel Subscribe Verb", needCancel: true, isCancelLeft: false, completion: { [weak self] success in
            if success {
                let requestModel = PostShowModels.Item.RequestModel(willSubscribe: false)
                self?.interactor?.subscribe(withRequestModel: requestModel)
                
                // Run spinner
                DispatchQueue.main.async {
                    sender.setTitle(nil, for: .normal)
                    self?.subscribeActivityIndicator.startAnimating()
                }
            }
            
            else {
                self?.subscribeActivityIndicator.stopAnimating()
            }
        })
    }
    
    @IBAction func subscribeButtonTappedDown(_ sender: UIButton) {
        sender.setBorder(color: UIColor(hexString: "#e3e3e3").cgColor, cornerRadius: 4.0 * heightRatio)
    }
    
    
}


// MARK: - PostShowDisplayLogic
extension PostShowViewController: PostShowDisplayLogic {
    func displaySubscribe(fromViewModel viewModel: PostShowModels.Item.ViewModel) {
        // NOTE: Display the result from the Presenter
        if let error = viewModel.errorAPI {
            self.showAlertView(withTitle: "Error", andMessage: error.localizedDescription, needCancel: false, completion: { _ in })
        }
        
        // Set post author subscribe button title
        DispatchQueue.main.asyncAfter(deadline: DispatchTime.now() + 0.5, execute: {
            self.showAlertView(withTitle:   viewModel.isFollowing ? "Subscribe Noun" : "Unsubscribe Noun",
                               andMessage:  (viewModel.isFollowing ? "Subscribe Success" : "Unsubscribe Success").localized() + "\n@\(self.postFeedHeaderView.authorNickNameButton.titleLabel!.text!.uppercaseFirst)", needCancel: false, completion: { [weak self] _ in
                self?.subscribeUserButton.isSelected = viewModel.isFollowing
                self?.subscribeUserButton.setTitle((viewModel.isFollowing ? "Subscriptions" : "Subscribe Verb").localized(), for: .normal)
                
                UIView.animate(withDuration: 0.5, animations: {
                    viewModel.isFollowing ? self?.subscribeUserButton.setBorder(color: UIColor(hexString: "#dbdbdb").cgColor, cornerRadius: 5.0) :
                                            self?.subscribeUserButton.fill(font: UIFont(name: "SFProDisplay-Medium", size: 10.0)!)
                }, completion: { success in
                    self?.subscribeActivityIndicator.stopAnimating()
                })
            })
        })
    }
    
    func displayLoadPostContent(fromViewModel viewModel: PostShowModels.Post.ViewModel) {
        // NOTE: Display the result from the Presenter
        Logger.log(message: "Success", event: .severe)

        if let error = viewModel.errorAPI {
            self.showAlertView(withTitle: "Error", andMessage: error.localizedDescription, needCancel: false, completion: { _ in })
        }
        
        // CoreData
        self.fetchPostContent(only: false)
    }
    
    func displayLoadPostComments(fromViewModel viewModel: PostShowModels.Post.ViewModel) {
        // NOTE: Display the result from the Presenter
        Logger.log(message: "Success", event: .severe)

        if let error = viewModel.errorAPI {
            self.showAlertView(withTitle: "Error", andMessage: error.localizedDescription, needCancel: false, completion: { _ in })
        }
        
        // Load Comments from CoreData
        DispatchQueue.main.asyncAfter(deadline: DispatchTime.now() + 0.1, execute: {
            self.fetchPostComments()
        })
    }
    
    func displayCheckFollowing(fromViewModel viewModel: PostShowModels.Following.ViewModel) {
        // NOTE: Display the result from the Presenter
        Logger.log(message: "Success", event: .severe)

        if let error = viewModel.errorAPI {
            self.showAlertView(withTitle: "Error", andMessage: error.localizedDescription, needCancel: false, completion: { _ in })
        }
        
        // Set post author subscribe button title
        DispatchQueue.main.async {
            self.subscribeUserButton.isSelected = viewModel.isFollowing
            self.subscribeUserButton.setTitle((viewModel.isFollowing ? "Subscriptions" : "Subscribe Verb").localized(), for: .normal)
           
            UIView.animate(withDuration: 0.5, animations: {
                viewModel.isFollowing ? self.subscribeUserButton.setBorder(color: UIColor(hexString: "#dbdbdb").cgColor, cornerRadius: 5.0) :
                                        self.subscribeUserButton.fill(font: UIFont(name: "SFProDisplay-Medium", size: 10.0)!)
            })
        }
    }
    
    func displayLikeVote(fromViewModel viewModel: PostShowModels.Like.ViewModel) {
        // NOTE: Display the result from the Presenter
        guard viewModel.errorAPI == nil else {
            if let message = viewModel.errorAPI?.caseInfo.message {
                self.showAlertView(withTitle:   viewModel.errorAPI!.caseInfo.title,
                                   andMessage:  message.translate(),
                                   needCancel:  false,
                                   completion:  { _ in
                                    // PostShow
                                    if viewModel.forPost {
                                        self.scrollCommentsDown = false
                                        self.fetchPostContent(only: true)
                                    }
                                    
                                    // CommentView
                                    else if let commentShortInfo = self.router?.dataStore?.comment, let indexPath = commentShortInfo.indexPath,
                                        let commentEntity = CoreDataManager.instance.readEntity(withName: "Comment",
                                                                                                andPredicateParameters: NSPredicate(format: "author == %@ AND permlink == %@", commentShortInfo.author!, commentShortInfo.permlink!)) as? Comment {
                                        (self.commentsStackView.arrangedSubviews[indexPath.row] as! CommentView).setupUI(withComment: commentEntity, forRow: indexPath.row)
                                    }
                })
            }
            
            return
        }
        
        // Reload & refresh content by indexPath
        DispatchQueue.main.asyncAfter(deadline: DispatchTime.now() + 0.1) {
            let postType = viewModel.forPost ? self.router!.dataStore!.postType : PostsFeedType.comment
            self.isPostContentModify = true
            
            if let postShortInfo = viewModel.forPost ? self.router?.dataStore?.postShortInfo : self.router?.dataStore?.comment, let indexPath = postShortInfo.indexPath {
                RestAPIManager.loadModifiedPost(author: postShortInfo.author ?? "XXX", permlink: postShortInfo.permlink ?? "XXX", postType: postType!, completion: { model in
                    // PostShow
                    if viewModel.forPost {
                        self.scrollCommentsDown = false
                        self.fetchPostContent(only: true)
                    }
                    
                    // CommentView
                    else if let commentEntity = model as? Comment {
                        // Modify Comment
                        (self.commentsStackView.arrangedSubviews[indexPath.row] as! CommentView).setupUI(withComment: commentEntity, forRow: indexPath.row)
                    }
                })
            }
        }
        
        // Amplitude SDK
        if viewModel.isLike == true {
            self.sendAmplitude(event: .like, actionName: "publish")
        }
        
        else if viewModel.isDislike == true {
            self.sendAmplitude(event: .dislike, actionName: "publish")
        }
    }
}


// MARK: - Load data from Blockchain by API
extension PostShowViewController {
    func loadPostContent() {
        self.loadPostContentWorkItem = DispatchWorkItem {
            self.gsTimer = GSTimer(operationName: "Load Post content...", time: 100.0, completion: { [weak self] success in
                if success && !(self?.loadPostContentWorkItem.isCancelled)! {
                    self?.loadPostContentWorkItem.cancel()
                    self?.loadPostContent()
                }
            })
            
            // Load Post
            let contentRequestModel = PostShowModels.Post.RequestModel()
            self.interactor?.loadPostContent(withRequestModel: contentRequestModel)
        }
        
        self.runCheckFollowingWorkItem = DispatchWorkItem {
            self.runCheckFollowing()
        }

        DispatchQueue.main.asyncAfter(deadline: DispatchTime.now() + 0.1, execute: self.loadPostContentWorkItem)
        DispatchQueue.main.asyncAfter(deadline: DispatchTime.now() + 0.5, execute: self.runCheckFollowingWorkItem)
    }
    
    func loadPostComments() {
        Logger.log(message: "Success", event: .severe)
        
        self.loadPostCommentsWorkItem = DispatchWorkItem {
            self.gsTimer = GSTimer(operationName: "Load Post Comments content...", time: 100, completion: { [weak self] success in
                if success && !(self?.loadPostCommentsWorkItem.isCancelled)! {
                    self?.loadPostCommentsWorkItem.cancel()
                    self?.loadPostComments()
                }
            })

            // Load Post Comments
            let contentRepliesRequestModel = PostShowModels.Post.RequestModel()
            self.interactor?.loadPostComments(withRequestModel: contentRepliesRequestModel)
        }
        
        DispatchQueue.main.asyncAfter(deadline: DispatchTime.now() + 0.1, execute: self.loadPostCommentsWorkItem)
    }
    
    private func runCheckFollowing() {
        Logger.log(message: "Success", event: .severe)

        guard isNetworkAvailable && !User.isAnonymous else {
            DispatchQueue.main.async {
                self.subscribeUserButton.isSelected = false
                self.subscribeUserButton.setTitle("Subscribe Verb".localized(), for: .normal)
                self.subscribeUserButton.fill(font: UIFont(name: "SFProDisplay-Medium", size: 10.0)!)
            }
            
            return
        }
        
        // API
        let requestModel = PostShowModels.Following.RequestModel()
        self.interactor?.checkFollowing(withRequestModel: requestModel)
    }
}


// MARK: - Fetch data from CoreData
extension PostShowViewController {
    // User Profile
    private func fetchPostContent(only: Bool) {
        let postType        =   self.router!.dataStore!.postType!
        let fetchRequest    =   NSFetchRequest<NSFetchRequestResult>(entityName: postType.caseTitle())
        
        if let userName = self.router?.dataStore?.postShortInfo?.author, let permlink = self.router?.dataStore?.postShortInfo?.permlink {
            fetchRequest.predicate = NSPredicate(format: "author == %@ AND permlink == %@", userName, permlink)
        }
        
        self.loadViewSettings(withoutComments: only)
    }
    
    private func fetchPostComments() {
        if let postShortInfo = self.router?.dataStore?.postShortInfo {
            guard var commentEntities = CoreDataManager.instance.readEntities(withName:                    "Comment",
                                                                              withPredicateParameters:     NSPredicate(format: "url contains[cd] %@ AND url contains[cd] %@", postShortInfo.author ?? "XXX", postShortInfo.permlink ?? "XXX"),
                                                                              andSortDescriptor:           nil) as? [Comment], commentEntities.count > 0 else {
                                                                                self.didFinishLoadComments(afterPagination: false)
                                                                                self.didCommentsControlView(hided: true)
                                                                                return
            }
            
            // Set comments levels
            let commentsFirstLevel = commentEntities.filter({ $0.parentPermlink == postShortInfo.permlink }).sorted(by: { $0.created < $1.created })
            commentsFirstLevel.forEach({ $0.treeLevel = 0 })
            
            let commentsSecondLevel = commentEntities.filter({ $0.parentPermlink != postShortInfo.permlink }).sorted(by: { $0.created < $1.created })
            commentsSecondLevel.forEach({ $0.treeLevel = 1 })
            
            for (index, comment) in commentsFirstLevel.enumerated() {
                comment.treeIndex = "\(index)"
                self.setViewTreeIndex(byComment: comment, andCommentsSecondLevel: commentsSecondLevel)
            }
            
            commentEntities = commentEntities.sorted(by: { $0.treeIndex < $1.treeIndex })
            
            self.commentsButton.setTitle("\(commentEntities.count)", for: .normal)
            self.commentsCountLabel.text = String(format: "%i", commentEntities.count)
            
            if self.permlinkCreatedItem != "" && self.insertedRow == nil {
                self.insertedRow = commentEntities.firstIndex(of: commentEntities.first(where: { $0.permlink == self.permlinkCreatedItem })!)
            }
            
            let startIndex  =   self.insertedRow ?? (self.comments?.count ?? 0 * self.paginationOffset)
            var endIndex    =   self.insertedRow ?? (startIndex + self.paginationOffset < commentEntities.count ? (startIndex + self.paginationOffset) : commentEntities.count)
            
            if endIndex == startIndex && self.insertedRow != nil {
                endIndex += 1
            }
            
            // Add comments to list first time
            if self.comments == nil {
                self.comments = Array(commentEntities[startIndex..<endIndex])
                self.isPaginationRun = false
            }
                
            // Add comments to list other time
            else if self.insertedRow == nil {
                self.comments!.append(contentsOf: Array(commentEntities[startIndex..<endIndex]))
            }
                
            // Add new comment to end of list
            else if self.insertedRow == self.comments!.count {
                self.comments!.append(contentsOf: Array(commentEntities[startIndex..<endIndex]))
            }
                
            // Add new Reply to list
            else {
                startIndex == commentEntities.count - 1 ?   self.comments!.append(commentEntities[startIndex]) :
                                                            self.comments!.insert(commentEntities[startIndex], at: startIndex)
            }
            
            // Sort comments list
            self.comments = self.comments!.sorted(by: { $0.treeIndex < $1.treeIndex })
            
            // Reload data
            self.commentViews   =   [CommentView]()
            var counter         =   startIndex
            
            // Create comments tree
            for index in startIndex..<endIndex {
                if let comment = self.comments?[index] {
                    let commentView = CommentView(withComment: comment, forRow: index)
                    commentView.localizeTitles()
                    
                    commentView.loadData(fromBody: comment.body, completion: { [weak self] height in
                        counter += 1
                        
                        commentView.markdownViewHeightConstraint.constant = height
                        commentView.frame.size = CGSize(width: commentView.frame.width, height: height + 79.0)
                        commentView.layoutIfNeeded()
                        
                        self?.commentsStackViewHeightConstraint.constant += height + 79.0
                        self?.commentViews?.append(commentView)
                        
                        if (counter == endIndex && self?.insertedRow == nil) || self?.insertedRow != nil {
                            for index in startIndex..<endIndex {
                                self?.insertedRow == nil || self?.insertedRow == self?.comments!.count ?
                                    self?.commentsStackView.addArrangedSubview((self?.commentViews!.first(where: { $0.treeIndex == index }))!) :
                                    self?.commentsStackView.insertArrangedSubview((self?.commentViews!.first(where: { $0.treeIndex == index }))!, at: index)
                                
                                // Hide UIStackView animation
                                UIView.performWithoutAnimation {
                                    self?.commentsStackView.setNeedsLayout()
                                    self?.commentsStackView.layoutIfNeeded()
                                }
                            }
                            
                            self?.needPagination = endIndex != commentEntities.count
                            self?.didFinishLoadComments(afterPagination: (self?.isPaginationRun)!)
                        }
                    })
                    
                    // Handlers
                    commentView.handlerLikeButtonTapped                             =   { [weak self] (isLike, postShortInfo) in
                        let handlersManager     =   HandlersManager()
                        let requestModel        =   PostShowModels.Like.RequestModel(isLike: isLike, isDislike: nil, forPost: false)

                        self?.interactor?.save(comment: postShortInfo)
                        
                        handlersManager.handlerTapped(isLike: isLike, completion: { [weak self] success in
                            guard let result = success else {
                                commentView.likeButton.startLikeVote(withSpinner: commentView.likeActivityIndicator)
                                self?.interactor?.likeVote(withRequestModel: requestModel)

                                return
                            }
                            
                            if result {
                                commentView.likeButton.startLikeVote(withSpinner: commentView.likeActivityIndicator)
                                self?.interactor?.likeVote(withRequestModel: requestModel)
                            }
                                
                            else {
                                commentView.likeButton.breakLikeVote(withSpinner: commentView.likeActivityIndicator)
                            }
                        })
                    }

                    commentView.handlerLikeCountButtonTapped                        =   { [weak self] postShortInfo in
                        DispatchQueue.main.async(execute: {
                            self?.interactor?.save(comment: postShortInfo)
                            self?.router?.routeToActiveVotersShowScene(asPost: false, withMode: .like)
                        })
                    }
                        
                    commentView.handlerDislikeButtonTapped                          =   { [weak self] (isDislike, postShortInfo) in
                        let handlersManager     =   HandlersManager()
                        let requestModel        =   PostShowModels.Like.RequestModel(isLike: nil, isDislike: isDislike, forPost: false)

                        self?.interactor?.save(comment: postShortInfo)
                        
                        handlersManager.handlerTapped(isDislike: isDislike, completion: { [weak self] success in
                            if success {
                                commentView.dislikeButton.startLikeVote(withSpinner: commentView.dislikeActivityIndicator)
                                self?.interactor?.likeVote(withRequestModel: requestModel)
                            }
                                
                            else {
                                commentView.dislikeButton.breakLikeVote(withSpinner: commentView.dislikeActivityIndicator)
                            }
                        })
                    }
                    
                    commentView.handlerDislikeCountButtonTapped                     =   { [weak self] postShortInfo in
                        DispatchQueue.main.async(execute: {
                            self?.interactor?.save(comment: postShortInfo)
                            self?.router?.routeToActiveVotersShowScene(asPost: false, withMode: .dislike)
                        })
                    }
                    
                    commentView.handlerUsersButtonTapped                            =   { [weak self] in
                        self?.showAlertView(withTitle: "Info", andMessage: "In development", needCancel: false, completion: { _ in })
                    }
                    
                    commentView.handlerCommentsButtonTapped                         =   { [weak self] postShortInfo in
                        guard (self?.isCurrentOperationPossible())! else { return }
                        
                        self?.interactor?.save(comment: postShortInfo)
                        self?.router?.routeToPostCreateScene(withType: .createComment)
                        self?.insertedRow = (postShortInfo.indexPath?.row)! + 1
                    }
                    
                    commentView.handlerReplyButtonTapped                            =   { [weak self] postShortInfo in
                        guard (self?.isCurrentOperationPossible())! else { return }
                        
                        self?.interactor?.save(comment: postShortInfo)
                        self?.router?.routeToPostCreateScene(withType: .createCommentReply)
                    }
                    
                    commentView.handlerRepostButtonTapped                           =   { [weak self] in
                        self?.showAlertView(withTitle: "Info", andMessage: "In development", needCancel: false, completion: { _ in })
                    }
                    
                    commentView.handlerAuthorProfileAddButtonTapped                 =   { [weak self] in
                        self?.showAlertView(withTitle: "Info", andMessage: "In development", needCancel: false, completion: { _ in })
                    }
                    
                    commentView.handlerAuthorProfileImageButtonTapped               =   { [weak self] authorName in
                        self?.router?.routeToUserProfileScene(byUserName: authorName)
                    }
                    
                    commentView.handlerAuthorNameButtonTapped                       =   { [weak self] authorName in
                        self?.router?.routeToUserProfileScene(byUserName: authorName)
                    }
                    
                    // Handler Markdown
                    commentView.markdownViewManager.completionErrorAlertView        =   { [weak self] errorMessage in
                        self?.showAlertView(withTitle: "Error", andMessage: errorMessage, needCancel: false, completion: { _ in })
                    }
                    
                    commentView.markdownViewManager.completionCommentAuthorTapped   =   { [weak self] authorName in
                        self?.router?.routeToUserProfileScene(byUserName: authorName)
                    }
                    
                    commentView.markdownViewManager.completionShowSafariURL         =   { [weak self] url in
                        self?.openExternalLink(byURL: url.absoluteString)
                    }
                }
            }
        }
    }
    
    // Build Post Comments views tree
    private func setViewTreeIndex(byComment comment: Comment, andCommentsSecondLevel commentsSecondLevel: [Comment]) {
        let commentChildrens = commentsSecondLevel.filter({ $0 != comment }).filter({ $0.parentPermlink!.contains(comment.permlink) })
        
        guard commentChildrens.count > 0 else {
            return
        }
        
        for (index, commentChildren) in commentChildrens.enumerated() {
            commentChildren.treeIndex = comment.treeIndex + "\(index)"
            self.setViewTreeIndex(byComment: commentChildren, andCommentsSecondLevel: commentsSecondLevel)
        }
    }
}


// MARK: - UICollectionViewDataSource
extension PostShowViewController: UICollectionViewDataSource {
    func numberOfSections(in collectionView: UICollectionView) -> Int {
        return 1
    }
    
    func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -> Int {
        // Return the number of items
        guard let displayedPost = self.router?.dataStore?.displayedPost, let dataSource = displayedPost.tags, dataSource.count > 0 else {
            return 0
        }
        
        return dataSource.count
    }
    
    func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell {
        let cell = collectionView.dequeueReusableCell(withReuseIdentifier: "PostShowTagCollectionViewCell", for: indexPath) as! PostShowTagCollectionViewCell
        let tag = self.router!.dataStore!.displayedPost!.tags![indexPath.row]
        
        // Config tag cell
        cell.setup(withItem: tag, andIndexPath: indexPath, blogEntry: nil)
        
        // Handlers
        cell.completionButtonTapped     =   {
            self.showAlertView(withTitle: "Info", andMessage: "In development", needCancel: false, completion: { _ in })
        }
        
        return cell
    }
}


// MARK: - UICollectionViewDelegate
extension PostShowViewController {
    func collectionView(_ collectionView: UICollectionView, didSelectItemAt indexPath: IndexPath) {}
}


// MARK: - UICollectionViewDelegateFlowLayout
extension PostShowViewController: UICollectionViewDelegateFlowLayout {
    func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, insetForSectionAt section: Int) -> UIEdgeInsets {
        return UIEdgeInsets.init(top: 0.0, left: 0.0, bottom: 0.0, right: 12.0)
    }
    
    func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, minimumInteritemSpacingForSectionAt section: Int) -> CGFloat {
        return 6.0 * widthRatio
    }
    
    func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, minimumLineSpacingForSectionAt section: Int) -> CGFloat {
        return 6.0 * heightRatio
    }
    
    func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, sizeForItemAt indexPath: IndexPath) -> CGSize {
        let tag     =   self.router!.dataStore!.displayedPost!.tags![indexPath.row]
        let width   =   (CGFloat(tag.count) * 7.0 + 30.0) * widthRatio
        
        if indexPath.row == 0 {
            self.tagsWidth = 0.0
        }
        
        self.tagsWidth  +=  width + 6.0 * heightRatio
        let lines       =   Int(self.tagsWidth / collectionView.frame.width) + 1
        
        self.tagsCollectionViewheightConstraint.constant = CGFloat(lines) * 30.0 * heightRatio + CGFloat(lines == 1 ? 0.0 : 6.0) * heightRatio
        
        return CGSize.init(width: width, height: 30.0 * heightRatio)
    }
}


// MARK: - UIScrollViewDelegate
extension PostShowViewController: UIScrollViewDelegate {
    func scrollViewDidScroll(_ scrollView: UIScrollView) {
        Logger.log(message: "contentOffset = \(scrollView.contentOffset.y)", event: .debug)
        
        let bottom          =   self.commentsStackView.frame.maxY - scrollView.frame.size.height
        let scrollPosition  =   scrollView.contentOffset.y
        
        if bottom - scrollPosition <= 50.0 && !self.isPaginationRun && self.needPagination {
            self.isPaginationRun = true
            self.infiniteScrollingView.show(constraint: self.infiniteScrollingViewBottomConstraint)

            // Load Comments from CoreData
            DispatchQueue.main.asyncAfter(deadline: DispatchTime.now() + 0.2, execute: {
                self.fetchPostComments()
            })
        }
    }
}
