//
//  PostShowInteractor.swift
//  golos-ios
//
//  Created by msm72 on 31.07.2018.
//  Copyright (c) 2018 golos. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit
import CoreData
import GoloSwift

// MARK: - Business Logic protocols
protocol PostShowBusinessLogic {
    func save(comment: PostShortInfo)
    func save(postShortInfo: PostShortInfo)
    func subscribe(withRequestModel requestModel: PostShowModels.Item.RequestModel)
    func loadContent(withRequestModel requestModel: PostShowModels.Post.RequestModel)
    func loadContentComments(withRequestModel requestModel: PostShowModels.Post.RequestModel)
    func checkFollowing(withRequestModel requestModel: PostShowModels.Following.RequestModel)
    func upvote(withRequestModel requestModel: PostShowModels.ActiveVote.RequestModel)
}

protocol PostShowDataStore {
    var comment: PostShortInfo? { get set }
    var postType: PostsFeedType? { get set }
    var postShortInfo: PostShortInfo? { get set }
    var displayedPost: PostCellSupport? { get set }
}

class PostShowInteractor: PostShowBusinessLogic, PostShowDataStore {
    // MARK: - Properties
    var presenter: PostShowPresentationLogic?
    
    // PostShowDataStore protocol implementation
    var comment: PostShortInfo?
    var postType: PostsFeedType?
    var postShortInfo: PostShortInfo?
    var displayedPost: PostCellSupport?

    
    // MARK: - Class Initialization
    deinit {
        Logger.log(message: "Success", event: .severe)
    }
    

    // MARK: - Business logic implementation
    func save(postShortInfo: PostShortInfo) {
        self.postShortInfo = postShortInfo
        
        if let selectedPost = CoreDataManager.instance.readEntity(withName:                   self.postType!.caseTitle().uppercaseFirst,
                                                                  andPredicateParameters:     NSPredicate(format: "id == \(postShortInfo.id ?? 0)")) as? PostCellSupport {
            self.displayedPost = selectedPost
        }
    }

    func save(comment: PostShortInfo) {
        self.comment = comment
    }
    
    func loadContent(withRequestModel requestModel: PostShowModels.Post.RequestModel) {
        // API 'get_content'
        let content = RequestParameterAPI.Content(author: self.postShortInfo?.author ?? "XXX", permlink: self.postShortInfo?.permlink ?? "XXX", active_votes: 1_000)
        
        RestAPIManager.loadPost(byContent: content, andPostType: self.postType!, completion: { [weak self] errorAPI in
            guard errorAPI?.caseInfo.message != "No Internet Connection" || !(errorAPI?.caseInfo.message.hasSuffix("timing"))! else {
                let responseModel = PostShowModels.Post.ResponseModel(errorAPI: errorAPI)
                self?.presenter?.presentLoadContent(fromResponseModel: responseModel)
                
                return
            }
            
            let responseModel = PostShowModels.Post.ResponseModel(errorAPI: nil)
            self?.presenter?.presentLoadContent(fromResponseModel: responseModel)
        })
    }

    func loadContentComments(withRequestModel requestModel: PostShowModels.Post.RequestModel) {
        // API 'get_all_content_replies'
        let content = RequestParameterAPI.Content(author: self.postShortInfo?.author ?? "XXX", permlink: self.postShortInfo?.permlink ?? "XXX")
        
        RestAPIManager.loadPostComments(byContent: content, andPostType: .comment, completion: { [weak self] errorAPI in
            guard errorAPI?.caseInfo.message != "No Internet Connection" || !(errorAPI?.caseInfo.message.hasSuffix("timing"))! else {
                let responseModel = PostShowModels.Post.ResponseModel(errorAPI: errorAPI)
                self?.presenter?.presentLoadContentComments(fromResponseModel: responseModel)
                
                return
            }
            
            let responseModel = PostShowModels.Post.ResponseModel(errorAPI: nil)
            self?.presenter?.presentLoadContentComments(fromResponseModel: responseModel)
        })
    }
    
    func checkFollowing(withRequestModel requestModel: PostShowModels.Following.RequestModel) {
        // API 'get_following'
        RestAPIManager.loadFollowingsList(byUserNickName: User.current!.nickName, authorNickName: self.postShortInfo?.author ?? "XXX", pagination: 1, completion: { [weak self] (isFollowing, errorAPI) in
            let responseModel = PostShowModels.Following.ResponseModel(isFollowing: isFollowing, errorAPI: errorAPI)
            self?.presenter?.presentCheckFollowing(fromResponseModel: responseModel)
        })
    }
    
    func subscribe(withRequestModel requestModel: PostShowModels.Item.RequestModel) {
        let subscription = RequestParameterAPI.Subscription(userNickName:       User.current!.nickName,
                                                            authorNickName:     self.postShortInfo!.author ?? "XXX",
                                                            what:               requestModel.willSubscribe ? "blog" : nil)
        
        let operationAPIType = OperationAPIType.subscribe(fields: subscription)
        let postRequestQueue = DispatchQueue.global(qos: .background)
        
        postRequestQueue.async {
            broadcast.executePOST(requestByOperationAPIType:    operationAPIType,
                                  userNickName:                 User.current!.nickName,
                                  onResult:                     { [weak self] responseAPIResult in
                                    var errorAPI: ErrorAPI?
                                    
                                    if let error = (responseAPIResult as! ResponseAPIBlockchainPostResult).error {
                                        errorAPI = ErrorAPI.requestFailed(message: error.message)
                                    }
                                    
                                    let isFollowing = errorAPI == nil && requestModel.willSubscribe
                                    
                                    let responseModel = PostShowModels.Item.ResponseModel(isFollowing: isFollowing, errorAPI: errorAPI)
                                    self?.presenter?.presentSubscribe(fromResponseModel: responseModel)
                },
                                  onError: { [weak self] errorAPI in
                                    Logger.log(message: "nresponse API Error = \(errorAPI.caseInfo.message)\n", event: .error)
                                    let responseModel = PostShowModels.Item.ResponseModel(isFollowing: false, errorAPI: errorAPI)
                                    self?.presenter?.presentSubscribe(fromResponseModel: responseModel)
            })
        }
    }
    
    func upvote(withRequestModel requestModel: PostShowModels.ActiveVote.RequestModel) {
        RestAPIManager.vote(up: requestModel.isUpvote, postShortInfo: self.postShortInfo!, completion: { [weak self] errorAPI in
            let responseModel = PostShowModels.ActiveVote.ResponseModel(isUpvote: requestModel.isUpvote, errorAPI: errorAPI)
            self?.presenter?.presentUpvote(fromResponseModel: responseModel)
        })
    }
}
