//
//  UserProfileShowInteractor.swift
//  golos-ios
//
//  Created by msm72 on 29.06.2018.
//  Copyright (c) 2018 golos. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit
import CoreData
import GoloSwift

// MARK: - Business Logic protocols
protocol UserProfileShowBusinessLogic {
    func saveLastReply(_ post: Reply?)
    func saveLastLenta(_ post: Lenta?)
    func loadUserInfo(withRequestModel requestModel: UserProfileShowModels.UserInfo.RequestModel)
    func loadUserDetails(withRequestModel requestModel: UserProfileShowModels.UserDetails.RequestModel)
}

protocol UserProfileShowDataStore {
    var lastReply: Reply? { get set }
    var lastLenta: Lenta? { get set }
}

class UserProfileShowInteractor: UserProfileShowBusinessLogic, UserProfileShowDataStore {
    // MARK: - Properties
    var presenter: UserProfileShowPresentationLogic?
    var worker: UserProfileShowWorker?

    
    // MARK: - UserProfileShowDataStore implementation
    var lastReply: Reply?
    var lastLenta: Lenta?

    
    // MARK: - Class Initialization
    deinit {
        Logger.log(message: "Success", event: .severe)
    }
    

    // MARK: - Business logic implementation
    func saveLastReply(_ post: Reply?) {
        self.lastReply  =   post
    }
    
    func saveLastLenta(_ post: Lenta?) {
        self.lastLenta  =   post
    }
    
    func loadUserInfo(withRequestModel requestModel: UserProfileShowModels.UserInfo.RequestModel) {
        worker = UserProfileShowWorker()

        // API 'get_accounts'
        if isNetworkAvailable {
            // Create MethodAPIType
            let names           =   User.current!.name
            let methodAPIType   =   MethodAPIType.getAccounts(names: RequestParameterAPI.User(names: [names]))
            
            broadcast.executeGET(byMethodAPIType: methodAPIType,
                                 onResult: { [weak self] responseAPIResult in
                                    Logger.log(message: "\nresponse API Result = \(responseAPIResult)\n", event: .debug)
                                    
                                    guard let userResult = (responseAPIResult as! ResponseAPIUserResult).result, userResult.count > 0 else {
                                        // Send empty User info
                                        let userInfoResponseModel = UserProfileShowModels.UserInfo.ResponseModel(error: nil)
                                        self?.presenter?.presentUserInfo(fromResponseModel: userInfoResponseModel)
                                        
                                        return
                                    }
                                    
                                    // CoreData: Update User entity
                                    if let userResponseAPI = userResult.first {
                                        let userEntity              =   User.instance(byUserID: userResponseAPI.id)
                                        userEntity.isAuthorized     =   true
                                        userEntity.updateEntity(fromResponseAPI: userResponseAPI)
                                    }
                                    
                                    // Send User info
                                    let userInfoResponseModel = UserProfileShowModels.UserInfo.ResponseModel(error: nil)
                                    self?.presenter?.presentUserInfo(fromResponseModel: userInfoResponseModel)
                },
                                 onError: { [weak self] errorAPI in
                                    Logger.log(message: "nresponse API Error = \(errorAPI.caseInfo.message)\n", event: .error)
                                    
                                    // Send error
                                    let userInfoResponseModel = UserProfileShowModels.UserInfo.ResponseModel(error: errorAPI)
                                    self?.presenter?.presentUserInfo(fromResponseModel: userInfoResponseModel)
            })
        }
        
        // Offline mode
        else {
            // Send User info
            let userInfoResponseModel = UserProfileShowModels.UserInfo.ResponseModel(error: nil)
            self.presenter?.presentUserInfo(fromResponseModel: userInfoResponseModel)
        }
    }
    
    func loadUserDetails(withRequestModel requestModel: UserProfileShowModels.UserDetails.RequestModel) {
        // API 'get_discussions_by_blog' & 'get_replies_by_last_update'
        if isNetworkAvailable {
            if let methodAPIType = worker?.prepareRequestMethod((type: requestModel.selectedControlIndex, lastLentaPost: lastLenta, lastReplyPost: lastReply)) {
                broadcast.executeGET(byMethodAPIType: methodAPIType,
                                     onResult: { [weak self] responseAPIResult in
                                        Logger.log(message: "\nresponse API Result = \(responseAPIResult)\n", event: .debug)
                                        
                                        guard let result = (responseAPIResult as! ResponseAPIFeedResult).result, result.count > 0 else {
                                            // Send User details
                                            let userDetailsBlogsResponseModel = UserProfileShowModels.UserDetails.ResponseModel(error: nil)
                                            self?.presenter?.presentUserDetails(fromResponseModel: userDetailsBlogsResponseModel)
                                            
                                            return
                                        }
                                        
                                        // CoreData: Update Post entity
                                        _ = result.map({ responseAPIFeed in
                                            switch requestModel.selectedControlIndex {
                                            // Reply
                                            case 1:
                                                Reply.updateEntity(fromResponseAPI: responseAPIFeed)

                                            // Lenta (blogs)
                                            default:
                                                Lenta.updateEntity(fromResponseAPI: responseAPIFeed)
                                            }
                                        })
                                        
                                        // Send User details
                                        let userDetailsResponseModel = UserProfileShowModels.UserDetails.ResponseModel(error: nil)
                                        self?.presenter?.presentUserDetails(fromResponseModel: userDetailsResponseModel)
                    },
                                     onError: { [weak self] errorAPI in
                                        Logger.log(message: "nresponse API Error = \(errorAPI.caseInfo.message)\n", event: .error)
                                        
                                        // Send error
                                        let userDetailsBlogsResponseModel = UserProfileShowModels.UserDetails.ResponseModel(error: errorAPI)
                                        self?.presenter?.presentUserDetails(fromResponseModel: userDetailsBlogsResponseModel)
                })
            }
        }
        
        // Offline mode
        else {
            // Send User details
            let userDetailsBlogsResponseModel = UserProfileShowModels.UserDetails.ResponseModel(error: nil)
            self.presenter?.presentUserDetails(fromResponseModel: userDetailsBlogsResponseModel)
        }
    }
}
